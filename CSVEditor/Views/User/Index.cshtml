@model List<CSVEditor.Models.UserRecord>
<style>
    body {
        font-family: Arial, sans-serif;
        display: flex;
        justify-content: center;
        padding: 40px;
        background-color: #f5f5f5;
    }

    .container {
        width: 800px;
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
    }

    th, td {
        padding: 8px 12px;
        text-align: left;
    }

    th {
        cursor: pointer;
        background: #eee;
    }

    tr:nth-child(even) { background: #f9f9f9; }

    .error-message {
        color: red;
        margin-top: 10px;
    }

    input[type=text], input[type=file] {
        padding: 6px;
        margin-right: 10px;
        margin-top: 10px;
    }

    button {
        padding: 6px 12px;
        margin-top: 10px;
        cursor: pointer;
    }
</style>


<div class="container">
    <form id="upload" method="post" enctype="multipart/form-data" action="/User/UploadFile">
        <input type="file" name="file"/>
        <button type="submit">Upload</button>
    </form>

    <div id="errorContainer" class="error-message" style="display:none;"></div>

    <input id="Search" placeholder="Search"/>

    <table id="tbl" border="1">
        <thead>
        <tr>
            <th onclick="sortTable(0)">FullName</th>
            <th onclick="sortTable(1)">Birthday</th>
            <th onclick="sortTable(2)">Married</th>
            <th onclick="sortTable(3)">Phone</th>
            <th onclick="sortTable(4)">Salary</th>
            <th>Actions</th>
        </tr>
        </thead>

        <tbody>
        @foreach (UserRecord r in Model)
        {
            <tr data-id="@r.Id">
                <td contenteditable>@r.FullName</td>
                <td contenteditable>@r.Birthday.ToString("dd-MM-yyyy")</td>
                <td contenteditable>@r.Married</td>
                <td contenteditable>@r.Phone</td>
                <td contenteditable>@r.Salary</td>
                <td>
                    <button onclick="save(this)">Save</button>
                    <button onclick="del(this)">Delete</button>
                </td>
            </tr>
        }
        </tbody>
    </table>

</div>

<script>

        document.addEventListener("DOMContentLoaded", function () {
            const searchInput = document.getElementById("Search");
            
            if (searchInput) {
                searchInput.oninput = (e) => {
                    let v = e.target.value.toLowerCase();
                    document.querySelectorAll("#tbl tbody tr").forEach(r => {
                        r.style.display = r.innerText.toLowerCase().includes(v) ? '' : 'none';
                    });
                };
            }
            
            const form = document.getElementById("upload");
            if (form) {
                form.addEventListener("submit", async function (e) {
                    e.preventDefault();
                    const formData = new FormData(form);
                    try {
                        const res = await fetch(form.action, { method: 'POST', body: formData });
                        const data = await res.json();

                        if (!res.ok) {
                            showError(data.csvErrors || "Unknown error");
                            return;
                        }
                        location.reload();
                    } catch (ex) {
                        showError("Server connection error");
                    }
                });
            }
        });

        async function save(b) {
            const tr = b.closest('tr');
            const c = tr.cells;

            const formattedDate = validateDate(c[1]);
            const isMarried = validateMarried(c[2]);
            const salary = validateSalary(c[4]);
            
            if (formattedDate === null || isMarried === null || salary === null) {
                return;
            }
            
            const record = {
                Id: parseInt(tr.dataset.id),
                FullName: c[0].innerText.trim(),
                Birthday: formattedDate,
                Married: isMarried,
                Phone: c[3].innerText.trim(),
                Salary: salary
            };

            try {
                const res = await fetch('/User/Update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(record)
                });

                if (!res.ok) {
                    const errorText = await res.text();
                    showError(errorText);
                } else {
                    alert("Saved successfully!");
                }
            } catch (ex) {
                showError("Save failed: " + ex.message);
            }
        }

        function validateDate(cell) {
            const raw = cell.innerText.trim();
            const match = raw.match(/^(\d{2})-(\d{2})-(\d{4})$/);

            if (!match) {
                showError("Birthday must be in dd-MM-yyyy format");
                return null;
            }

            const isoDate = `${match[3]}-${match[2]}-${match[1]}`;
            if (isNaN(new Date(isoDate).getTime())) {
                showError("Invalid calendar date");
                return null;
            }
            return isoDate;
        }

        function validateMarried(cell) {
            const val = cell.innerText.trim().toLowerCase();
            if (val !== 'true' && val !== 'false') {
                showError("Married status must be 'true' or 'false'");
                return null;
            }
            return val === 'true';
        }

        function validateSalary(cell) {
            const val = cell.innerText.trim();
            if (!val.match(/^\d+([.,]\d+)?$/)) {
                showError("Salary field must contain numbers only");
                return null;
            }
            return parseFloat(val);
        }

        async function del(b) {
            if(!confirm("Delete this record?")) return;
            let tr = b.closest('tr');
            let id = tr.dataset.id;
            const res = await fetch('/User/Delete/' + id, { method: 'DELETE' });
            if(res.ok) tr.remove();
        }

        function showError(messages) {
            const container = document.getElementById("errorContainer");
            container.style.display = 'block';

            if (Array.isArray(messages)) {
                container.innerHTML = messages.map(m => `<p>• ${m}</p>`).join('');
            } else {
                container.innerHTML = `<p>${messages}</p>`;
            }

            setTimeout(() => { container.style.display = 'none'; }, 10000);
        }
        
</script>

<script>
    const sortStates = {};

    function sortTable(columnIndex) {
        const table = document.getElementById("tbl");
        const tbody = table.tBodies[0];
        const rows = Array.from(tbody.rows);
        
        const currentState = sortStates[columnIndex] || 'default';
        let newState;
        
        if (currentState === 'default') newState = 'asc';
        else if (currentState === 'asc') newState = 'desc';
        else newState = 'default';

        sortStates[columnIndex] = newState;

        rows.sort((rowA, rowB) => {
            if (newState === 'default') {
                return parseInt(rowA.dataset.id) - parseInt(rowB.dataset.id);
            }

            const cellA = rowA.cells[columnIndex].innerText.trim();
            const cellB = rowB.cells[columnIndex].innerText.trim();
            const multiplier = newState === 'asc' ? 1 : -1;

            switch (columnIndex) {
                case 1: return (parseDate(cellA) - parseDate(cellB)) * multiplier;
                case 2: 
                    const bA = cellA.toLowerCase() === 'true';
                    const bB = cellB.toLowerCase() === 'true';
                    return (bA === bB ? 0 : bA ? 1 : -1) * multiplier;
                case 4: 
                    return (parseFloat(cellA.replace(',', '.')) - parseFloat(cellB.replace(',', '.'))) * multiplier;
                default: return cellA.localeCompare(cellB) * multiplier;
            }
        });

        updateSortIcons(table, columnIndex, newState);
        rows.forEach(row => tbody.appendChild(row));
    }

    function parseDate(s) {
        const p = s.split('-');
        return p.length === 3 ? new Date(p[2], p[1] - 1, p[0]) : new Date(0);
    }

    function updateSortIcons(table, activeIndex, state) {
        const headers = table.querySelectorAll("thead th");
        headers.forEach((th, idx) => {
            th.innerText = th.innerText.replace(/ (ascending|descending|default)$/gi, "");
            if (idx === activeIndex) {
                if (state === 'asc') th.innerText += " ascending";
                else if (state === 'desc') th.innerText += " descending";
                else if (state === 'default') th.innerText += " default";
            }
        });
    }
    
    document.addEventListener("DOMContentLoaded", function () {
        const searchInput = document.getElementById("Search");
        if (searchInput) {
            searchInput.oninput = (e) => {
                let v = e.target.value.toLowerCase();
                document.querySelectorAll("#tbl tbody tr").forEach(r => {
                    r.style.display = r.innerText.toLowerCase().includes(v) ? '' : 'none';
                });
            };
        }
    });
</script>